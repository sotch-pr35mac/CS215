 %% Based on a TeXnicCenter-Template by Tino Weinkauf.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% HEADER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\documentclass[onecolumn, 11pt, conference, compsocconf]{IEEEtran}
\documentclass[onecolumn, 12pt, article]{IEEEtran}
\usepackage{times,color,amsmath,amssymb,amsthm,comment,graphicx,cite,multirow}
%\documentclass[letterpaper,oneside,11pt]{letter}
% Alternative Options:
%	Paper Size: a4paper / a5paper / b5paper / letterpaper / legalpaper / executivepaper
% Duplex: oneside / twoside
% Base Font Size: 10pt / 11pt / 12pt


%% Language %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[USenglish]{babel} %francais, polish, spanish, ...
\usepackage[T1]{fontenc}
\usepackage[ansinew]{inputenc}

\usepackage{lmodern} %Type1-font for non-english texts and characters
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{float}

%% Packages for Graphics & Figures %%%%%%%%%%%%%%%%%%%%%%%%%%
%\usepackage{graphicx} %%For loading graphic files
%\usepackage{subfig} %%Subfigures inside a figure
%\usepackage{tikz} %%Generate vector graphics from within LaTeX

%% Please note:
%% Images can be included using \includegraphics{filename}
%% resp. using the dialog in the Insert menu.
%% 
%% The mode "LaTeX => PDF" allows the following formats:
%%   .jpg  .png  .pdf  .mps
%% 
%% The modes "LaTeX => DVI", "LaTeX => PS" und "LaTeX => PS => PDF"
%% allow the following formats:
%%   .eps  .ps  .bmp  .pict  .pntg


%% Math Packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
%\usepackage{array,MnSymbol}


%% Line Spacing %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{setspace}
\singlespacing        %% 1-spacing (default)
%\onehalfspacing       %% 1,5-spacing
%\doublespacing        %% 2-spacing


%% Other Packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\usepackage{a4wide} %%Smaller margins = more text per page.
\usepackage{fancyhdr} %%Fancy headings
\usepackage{listings}
\usepackage{capt-of}


%
% Theorem like environments
%
\newtheorem{problem}{Problem}%
%\numberwithin{problem}{section}
\newtheorem{theorem}{Theorem}%
\newtheorem{acknowledgment}{Acknowledgment}%
%\newtheorem{algorithm}{Algorithm}%
\newtheorem{assumption}{Assumption}%
\newtheorem{axiom}{Axiom}%
\newtheorem{case}{Case}%
\numberwithin{case}{problem}
\newtheorem{claim}{Claim}%
\newtheorem{conclusion}{Conclusion}
\newtheorem{condition}{Condition}
\numberwithin{condition}{problem}
\numberwithin{condition}{subsection}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{criterion}{Criterion}
\newtheorem{definition}{Definition}
\numberwithin{definition}{section}
\newtheorem{example}{Example}
\newtheorem{exercise}{Exercise}%
\newtheorem{lemma}{Lemma}%
\newtheorem{notation}{Notation}%
\theoremstyle{remark}
\newtheorem{question}{Question}%
\numberwithin{question}{problem}
\theoremstyle{plain}
\newtheorem{answer}{Answer}%
\numberwithin{answer}{problem}
\newtheorem{proposition}{Proposition}%
\newtheorem{remark}{Remark}%
\newtheorem{solution}{Solution}%
\numberwithin{solution}{section}
\newtheorem{summary}{Summary}%
\numberwithin{equation}{section}%
\newtheorem{option}{Option}



\raggedbottom
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Remarks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Note:
% 1. Edit the used packages and their options (see above).
% 2. If you want, add a BibTeX-File to the project
%    (e.g., 'literature.bib').
% 3. Happy TeXing!
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Options / Modifications
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\input{options} %You need a file 'options.tex' for this
%% ==> TeXnicCenter supplies some possible option files
%% ==> with its-templates (File | New from Template...).





%% BEGIN DOCUMENT
\begin{document}

%% Title Page
\title{Java Sorting Algorithms Comparison}
\author{Preston Stosur-Bassett}
\date{February 23, 2015}
\maketitle

\pagestyle{fancy}
\fancyhead[R]{Java Sorting Algorithms Run-Time Analysis, page \thepage}
\fancyhead[L]{Preston Stosur-Bassett}

%% BEGIN ABSTRACT
\begin{abstract}

%% END ABSTRACT
\end{abstract}

%% BEGIN MOTIVATION
\section{Motivation}
In order to show how an algorithm might run on a given set of hardware, and how the algorithm will perform when given large amounts of data, algorithms are analysed. Sorting algorithms sort data into a natural order. By analysing sorting algorithms, the fastest algorithm for a given problem can be determined. 
%% END MOTIVATION

%% BEGIN BACKGROUND
\section{Background}
A sorting algorithm is used to sort data with a natural order. One such sorting algorithm is insertion sort, which sorts by iterating through a list of data, taking the current position, and repositioning it into a more appropriate place in the list. Heap sort is another sorting algorithm that greatly differs than insertion sort in that it uses a divide, conquer, and combine method; meaning that it breaks the set it is sorting into subsets until the subsets can no longer be broken up and then merge sort combines the subsets together rendering the correct answer. %% Write this for heap sort. 
%% END BACKGROUND

%% BEGIN PROCEDURE
\section{Procedure}
An insertion sort can be implemented in a multitude of languages using the pseudocode provided in Algorithm 1.
\newline
\textbf{Insertion Sort Pre-Condition}: A is a non-empty array of data with a natural order.
\newline
\textbf{Insertion Sort Post-Condition}: A' is a permutation of A (containing all the same elements) in strictly non-decreasing order.
\begin{algorithm}
\caption {\textsc{Insertion-Sort}(A)}
\label{algo:insertionsort}
\begin{algorithmic}[1]
\Procedure{Insertion-Sort}{A}
\If{$A.length < 2$}
\State{\Return{$A$}}
\EndIf
\State{$i = 2$}
\While{$i$ upto $A.length$}
	\State{$key = A[i]$}
	\State{$j = i - 1$}
	\While{$j$ downto $1$ and $key < A[j]$}
		\State{$A[j + 1] = A[j]$}
		\State{$j = j - 1$}
	\EndWhile
	\State{$A[j+1] = key$}
	\State{$i = i + 1$}
\EndWhile
\State{\Return{$A$}}
\EndProcedure
\end{algorithmic}
\end{algorithm}
\newline
\textbf{Insertion Sort Outer-Loop Invariant}: The subarray A'[1 ... i - 1] contains all the same elements as the subarray A[1 .. i - 1].
\newline 
\textbf{Insertion Sort Outer-Loop Initialization}: The outer-loop invariant holds because A'[1 ... i - 1] and A[1 ... i - 1] both contain the same one element.
\newline
\textbf{Insertion Sort Outer-Loop Maintenance}: The outer-loop invariant holds because A'[1 ... i - 1] and A[1 ... i - 1] both contain the same elements, although they may be in different orders.
\newline
\textbf{Insertion Sort Outer-Loop Termination}: When the outer-loop terminates, i = A.length, which implies that the entire array has been traversed and the guard has been negated. The negation of the guard implies that A'[1 ... i - 1] contains all the elements in A[1 ... i - 1].
\newline
\newline
\textbf{Insertion Sort Inner-Loop Invariant}: A'[1 ... j] is sorted in strictly non-decreasing order.
\newline
\textbf{Insertion Sort Inner-Loop Initialization}: Before the first iteration of the loop, j = 1, meaning the subarray A'[1 ... j] contains exactly one element, which is already sorted.
\newline
\textbf{Insertion Sort Inner-Loop Maintenance}: At the beginning of each iteration of the loop the inner-loop invariant holds because j counts down from i, and A'[j+1] is swapped with A'[j] only if A'[j+1] is less than A[j].
\newline
\textbf{Insertion Sort Inner-Loop Termination}: The negation of the guard implies that j = A.length and that A'[1 ... j] has been entirely traversed and sorted in strictly non-decreasing order, which maintains the inner-loop invariant. 
\newline
\newline
\textbf{Insertion Sort Conclusion}: The termination of both the inner and outer loops implies that the entire array has been traversed, A' is a permutation of A containing all the same elements in strictly non-decreasing order. This satisfies the post condition.
\newline
\newline

A merge sort can be implemented in a variety of languages using the pseudocode provided in Algorithm 2.
\newline
\textbf{Merge Sort Pre-Condition}: A is a non-empty array of a comparable data with a natural order.
\newline
\textbf{Merge Sort Post-Condition}: A' is a permutation of A (containing all the same elements) in strictly non-decreasing order.
\newline
\textbf{Merge Pre-Condition}: Left and right are both non-empty arrays of a comparable data type with a natural order in strictly non-decreasing order.
\newline
\textbf{Merge Post-Condition}: Combined has all the elements of both left and right in strictly non-decreasing order.
\begin{algorithm}
\caption {\textsc{Merge-Sort}(A)}
\label{algo:mergesort}
\begin{algorithmic}[1]
\Procedure{Merge-Sort}{A}
\If{$A.length < 2$}
\State{\Return{$A$}}
\EndIf
\State{$mid = A.length / 2$}
\For{$i = 1$ upto $mid$}
	\State{$left[left.length] = A[i]$}
\EndFor
\For{$i = mid$ upto $A.length$}
	\State{$right[right.length] = A[i]$}
\EndFor
\State{$left =$ Merge-Sort($left$)}
\State{$right =$ Merge-Sort($right$)}
\State{$A =$ Merge($left$, $right$)}
\State{\Return{$A$}}
\EndProcedure
\newline
\Procedure{Merge}{left, right}
\State{$var$ $i = 0$}
\State{$var$ $y = 0$}
\State{$var$ $x = 0$}
\While{$left.length$ $!=$ $i$ and $right.length$ $!=$ $y$}
	\If{$left[i] < right[y]$}
		\State{$combined[x] = left[i]$}
		\State{$i = i + 1$}
		\State{$x = x + 1$}
	\EndIf
	\If{$right[y] < left[i]$}
		\State{$combned[x] = right[y]$}
		\State{$y = y + 1$}
		\State{$x = x + 1$}
	\EndIf
\EndWhile
\While{$left.length$ $!=$ $i$}
	\State{$combined[x] = left[i]$}
	\State{$i = i + 1$}
	\State{$x = x + 1$}
\EndWhile
\While{$right.length$ $!=$ $y$}
	\State{$combined[x] = right[y]$}
	\State{$y = y + 1$}
	\State{$x = x + 1$}
\EndWhile
\State{\Return{$combined$}}
\EndProcedure
\end{algorithmic}
\end{algorithm}
\newline
%% TODO: Add pre and post conditions here
A heap sort can be implemented in a variety of languages using the pseudocode below in Algorithm 3.
\newline
\begin{algorithm}
\caption {\textsc{Heap-Sort}(A)}
\label{algo:heapsort}
\begin{algorithmic}[1]
\Procedure{Heapify}{A, i, total}
\State{$var$ $left = i * 2$}
\State{$var$ $right = left + 1$}
\State{$var$ $iPrime = i$}
\If{$left <= total$ and $A[left] > A[i]$}
	\State{$i = left$}
\EndIf
\If{$right <= total$ and $A[right] > A[i]$}
	\State{$i = right$}
\EndIf
\If{$i != iPrime$}
	\State{$var$ $temp = A[iPrime]$}
	\State{$A[iPrime] = A[i]$}
	\State{$A[i] = tmp$}
	\State{$A = heapify(A, i, total)$}
\EndIf
\State{\Return{$A$}}
\EndProcedure
\Procedure{Heap-Sort}{A}
\State{$var$ $size = A.length$}
\For{$var$ $i = size / 2$ downto $1$}
	\State{$A = heapify(A, i, size$}
\EndFor
\For{$var$ $i = size$ downto $1$}
	\State{$var$ $tmp = A[1]$}
	\State{$A[0] = A[i]$}
	\State{$A[i] = tmp$}
	\State{$size = size - 1$}
	\State{$A = heapify(A, 1, size)$}
\EndFor
\State{\Return{$A$}}
\EndProcedure
\end{algorithmic}
\end{algorithm}
%% END PROCEDURE

%% BEGIN TESTING
\section{Testing}
\subsection{Testing Plan and Results}
All arrays used in testing are Java ArrayList<Integer> unless otherwise spcified. All times are recorded in milliseconds using a stopwatch class borrowed from Robert Sedgewock and Kevin Wayne %%TODO: Cite this shit.
It is important to note that the soptwatch class used takes the elapsed real-time between the start of the sort algorithm and the end of the sort algorithim as opposed to taking the elapsed processor-time becasue these tests were run on a multi-core computer.
In the table below, A denotes Array. Times in the table below are given as averages out of 10 trials.
\newline
\captionof{table}{Insertion Sort Test Results}
\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline Tested Input & Expected Results & Actual Results & Time \\
\hline Empty A & Empty A & Empty A & 0.0003 \\
\hline A of 1000 Strings & Sorted A 1000 Strings & Sorted A 1000 Strings & 0.021 \\
\hline A 1 Element & Original A & Original A & 0.0003 \\
\hline A 10 Elements & Sorted A 10 Elements & Sorted A 10 Elements & 0.0005 \\
\hline A 100 Elements & Sorted A 100 Elements & Sorted A 100 Elements & 0.0021 \\
\hline A 1000 Elements & Sorted A 1000 Elements & Sorted A 1000 Elements & 0.019 \\
\hline A 10000 Elements & Sorted A 10000 Elements & Sorted A 10000 Elements & 0.129 \\
\hline A 100000 Elements & Sorted A 100000 Elements & Sorted A 100000 Elements & 6.4923 \\
\hline A 1000000 Elements & Sorted A 1000000 Elements & Sorted A 1000000 Elements & 2135.5007 \\
\hline A 10000000 Elements & Sorted A 10000000 Elements & OS Crash & N/A \\
\hline A 1000 Identical Elements & Original Array & Original Array & 0.0052 \\
\hline
\end{tabular}
\end{center}
\newline
\captionof{table}{Merge Sort Test Results}
\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline Tested Input & Expected Results & Actual Results & Time \\
\hline Empty A & Empty A & Empty A & 0.0002 \\
\hline A 1 Element & Original A & Original A & 0.0001 \\
\hline A 10 Elements & Sorted A 10 Elements & Sorted A 10 Elements & 0.0004 \\
\hline A 100 Elements & Sorted A 100 Elements & Sorted A 100 Elements & 0.0028 \\
\hline A 1000 Elements & Sorted A 1000 Elements & Sorted A 1000 Elements & 0.0294 \\
\hline A 10000 Elements & Sorted A 10000 Elements & Sorted A 10000 Elements & 0.2098 \\
\hline A 100000 Elements & Sorted A 100000 Elements & Sorted A 100000 Elements & 2.1904 \\
\hline A 1000000 Elements & Sorted A 1000000 Elements & Sorted A 1000000 Elements & 22.9314 \\
\hline 
\hline
\end{tabular}
\end{center}
\subsection{Problems Encountered}

%% END TESTING

%% BEGIN EXPERIMENTAL ANALYSIS
\section{Experimental Analysis}

%% END EXPERIMENTAL ANALYSIS

%% BEGIN CONCLUSION
\section{Conclusions}

%% END CONCLUSION

\newpage

%% BEGIN REFERENCES
 \section*{References}

%%\nocite{*}
%%\bibligraphystyle{IEEEtran}
%%\bibliography{}

%% END REFERENCES

\newpage

%% BEGIN APPENDIX
\section*{Appendix}

%% END APPENDIX

%% END DOCUMENT
\end{document}
